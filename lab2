#ant colony
import numpy as np, random
class AntColony:
    def __init__(s, d, a, i, α=1, β=2, e=0.5, Q=100):
        s.d, s.p, s.a, s.i, s.α, s.β, s.e, s.Q, s.n = d, np.ones(d.shape)/len(d), a, i, α, β, e, Q, len(d)
    def run(s):
        b, l = None, float('inf')
        for _ in range(s.i):
            p, L = s.solve()
            print("Paths:", p)
            print("Lengths:", L)
            s.update(p, L)
            if min(L) < l: b, l = p[np.argmin(L)], min(L)
        return b, l
    def solve(s):
        P, L = [], []
        for _ in range(s.a):
            p = s.path()
            P.append(p), L.append(s.length(p))
        return P, L
    def path(s):
        p = [random.randint(0, s.n - 1)]
        while len(p) < s.n: p.append(s.next(p))
        return p
    def next(s, p):
        c = p[-1]
        probs = []
        for n in range(s.n):
            if n not in p:
                prob = (s.p[c][n] ** s.α) * (1 / s.d[c][n]) ** s.β
                probs.append((n, prob))

        total = sum(pr for _, pr in probs)
        r = random.random() * total
        for n, pr in probs:
            r -= pr
            if r <= 0:
                return n
    def length(s, p): return sum(s.d[p[i-1]][p[i]] for i in range(1, len(p)))

    def update(s, P, L):
        s.p *= (1 - s.e)
        for p, l in zip(P, L):
            for i in range(len(p) - 1):
                s.p[p[i]][p[i+1]] += s.Q / l
                s.p[p[i+1]][p[i]] += s.Q / l

distances = np.array([
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
])

aco = AntColony(distances, a=5, i=100)
best_path, best_length = aco.run()
print("Best path:", best_path)
print("Best length:", best_length)




#genetic algorithm
import random
POPULATION_SIZE = 100
GENE_LENGTH = 20
MUTATION_RATE = 0.01
GENERATIONS = 100
def fitness(individual):
    return sum(individual)
def create_individual():
    return [random.randint(0, 1) for _ in range(GENE_LENGTH)]

def create_population():
    return [create_individual() for _ in range(POPULATION_SIZE)]
def select(population):
    tournament = random.sample(population, 5)
    return max(tournament, key=fitness)
def crossover(parent1, parent2):
    point = random.randint(1, GENE_LENGTH - 1)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2
def mutate(individual):
    return [gene if random.random() > MUTATION_RATE else 1 - gene for gene in individual]
def genetic_algorithm():
    population = create_population()
    for generation in range(GENERATIONS):
        population = sorted(population, key=fitness, reverse=True)

        new_population = population[:10]

        while len(new_population) < POPULATION_SIZE:
            parent1 = select(population)
            parent2 = select(population)
            child1, child2 = crossover(parent1, parent2)
            new_population.extend([mutate(child1), mutate(child2)])

        population = new_population[:POPULATION_SIZE]

        best_fitness = max(fitness(ind) for ind in population)
        print(f"Generation {generation + 1}: Best Fitness = {best_fitness}")

    best_individual = max(population, key=fitness)
    print("Best Individual:", best_individual)

genetic_algorithm()
